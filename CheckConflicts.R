# Core R Functions for processing student/professor conflicts for the optimized
# schedules

require(tidyverse)


#' convert_to_minutes
#' 
#' Converts standard 24:00 hour calendar into total minutes in the day. 
#'
#' @param time 
#'
#' @return
#' @export
#'
#' @examples
convert_to_minutes <- function(time){
  time_hour <- floor(time/100)
  time_minute <- time - (time_hour*100)
  time_in_minutes = time_hour*60 + time_minute
  ifelse(time_in_minutes > (60*24),NA,time_in_minutes)
}


#' clean_student_data
#' 
#' clean the student data provided by the university.
#'
#' @param data raw student data provided by the university
#'
#' @return data.frame containing the cleaned version of the data. 
#' @export
clean_student_data = function(data){
  data %>% 
    janitor::clean_names() %>% 
    select(guid,course_id,days,bldg=building,room,times) %>% 
    separate(col = course_id, into=c("course","section"),sep="-") %>% 
    separate(col=times, into = c("orig_start_time","orig_end_time"),sep="-",remove = F) %>% 
    mutate(orig_start_time = convert_to_minutes(as.numeric(orig_start_time)),
           orig_end_time = convert_to_minutes(as.numeric(orig_end_time))) %>%
    select(-section) %>% 
    
    # Drop all class entries with missing information (i.e. classes that aren't
    # assigned to a specific build, time, or students that don't actually have a
    # course schedule)
    filter(!is.na(bldg)) %>% 
    filter(!is.na(room)) %>% 
    
    # Drop courses without actual times assigned to them
    filter(times !=  "-")
}


#' map_schedules
#'
#' Map the student schedules to the optimized schedule. This will allow for
#' comparisons down the line.
#'
#' @param student_schedule student schedules provided by the university
#' @param optimized_schedule optimized schedule generated to minimize congestion.
#'
#' @return merged version student schedule broken up by day and class.
#' @export
map_schedules <- function(student_schedule,optimized_schedule){
  # Join optimize schedule with student scheduled
  optimized_schedule %>% 
    select(bldg,room,days,adj_start_time=start_time,adj_end_time=end_time,orig_start_time,orig_end_time) %>% 
    right_join(student_schedule,by = c("bldg", "room", "days", "orig_start_time", "orig_end_time")) %>% 
    
    # Break up the days into invidiual rpws
    mutate("M"=str_detect(days,"M"),
           "T"=str_detect(days,"T"),
           "W"=str_detect(days,"W"),
           "R"=str_detect(days,"R"),
           "F"=str_detect(days,"F"),
           "S"=str_detect(days,"S"),
           "U"=str_detect(days,"U")) %>% 
    
    # alter the unit of analysis 
    pivot_longer(cols=c(M,T,W,R,F,S,U),names_to = "day") %>% 
    
    # Recover the relevant components
    select(day,value,everything()) %>% 
    filter(value) %>% 
    select(-value,-times) %>% 
    
    # Order the factors. 
    mutate(day = factor(day,levels=c("M","T","W","R","F","S","U")))  %>% 
    
    select(guid,course,day,everything())
}


#' overlap_score
#'
#' calculate the degree of overlap between two classes. Values under 1 signifies
#' an overlapping class.
#'
#' @param start_time_1 start time of the class
#' @param end_time_1 end time of the class
#' @param start_time_2 start time of the class being compared
#' @param end_time_2 end time of the class being compared
#' @param buffer an additional adjustment to the required time
#'   between compared class entries (e.g. allows a way of imposing a strict M
#'   number of minutes that must exist between classes, else it should be
#'   considered an overlap)
#'
#' @return a positively defined score (float)
#' @export
#'
#' @examples
overlap_score = function(start_time_1=NA,end_time_1=NA,
                         start_time_2=NA,end_time_2=NA,
                         buffer = 0){
  total_time = (end_time_2 - start_time_1)
  time_between = (end_time_1 + buffer - start_time_2)
  time_a = end_time_1 + buffer - start_time_1
  time_b = end_time_2 - start_time_2
  score = (total_time - time_between)/ (time_a + time_b)
  return(abs(score))
} 



#' calc_conflicts
#'
#' For each GUID in the data (i.e. student), calculate the number of conflicts.
#'
#' A "conflict" is defined as two courses overlapping within a student schedule.
#' Conflicts signify instances when a student would have to amend their schedule
#' under the adjusted regime.
#'
#' @param data a data.frame generated by `map_schedules()`
#' @param period_between_classes integer specifying the required period that
#'   must existed between classes. Default is 10 (minutes). 
#' @param return_conflicts return data on the conflicting classes, rather than
#'   the summary statistics. Allows for inspection. Default is FALSE. 
#'
#' @return a data.frame containing guid and n_conflicts.
#' @export
calc_conflicts <- function(data,period_between_classes = 10,return_conflicts = F){
  
  # generate the comparison versions of the data to join 
  D = data %>% select(guid,course,day,contains("adj")) 
  
  # Overlap data 
  tmp <- 
    
    # Gather the two types
    full_join(D,D,by = c("guid","day"),suffix = c("_x", "_y")) %>% 
    
    # Drop any instances of the same course
    filter(course_y != course_x,adj_start_time_x != adj_start_time_y) %>% 
    
    # Calculate the overlap
    mutate(overlap = overlap_score(adj_start_time_x,adj_end_time_x,
                                   adj_start_time_y,adj_end_time_y,
                                   buffer = period_between_classes))
  
  if(return_conflicts){
    tmp %>% 
      filter(overlap < 1) %>%
      select(guid,day,overlap,contains("course"),contains("start"),contains("end")) %>% 
      unite("time_x", adj_start_time_x,adj_end_time_x,sep=" - ") %>% 
      unite("time_y", adj_start_time_y,adj_end_time_y,sep=" - ") 
  }else{
    
    # locate all students that have no classes on the same day (thus have no
    # opportunity for conflict)
    no_same_day_classes <- 
      data %>% 
      group_by(guid,day) %>% 
      count() %>% 
      group_by(guid) %>% 
      summarize(class_ratio = sum(n)/n_distinct(day)) %>% 
      filter(class_ratio <= 1) %>% 
      transmute(guid,n_conflicts=0)
    
    # All students that have more than one class on the same day
    with_same_day_classes <- 
      tmp %>% 
      # Sum up the number of conflict (divide by two since both sides of the matrix
      # are computed in the join)
      group_by(guid) %>% 
      summarize(n_conflicts = (sum(overlap < 1))/2 )
    
    # Return the complete guid list
    bind_rows(with_same_day_classes,no_same_day_classes) %>% 
      arrange(guid)
  }
}

